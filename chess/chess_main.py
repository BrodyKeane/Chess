'''
This is the main driver file. It will be responsible for handling user input and displaying the
current GameState object.
'''

import pygame as p
import chess_engine

#GLOBAL VARIABLES

WIDTH = HEIGHT = 512 #400 if quality too low (divisible by 8)
DIMENSION = 8 #chess board is 8x8
SQ_SIZE = HEIGHT // DIMENSION 
MAX_FPS = 15 #for animations
IMAGES = {}


'''
init gloabl dictionary of images. ONLY CALLED ONCE IN MAIN (loading images in pygame is expensive)
'''

def load_images():
    
    pieces = ['bR', 'bN', 'bB', 'bQ', 'bK', 'bP', 'wR', 'wN', 'wB', 'wQ', 'wK', 'wP']

    #loads all images of pieces and assigns them to a dictionary. #key = piece name | value = png
    #images are transformed to SQ_SIZE X SQ_SIZE
    for piece in pieces: 
        IMAGES[piece] = p.transform.scale(p.image.load(f"chess/images/{piece}.png"), (SQ_SIZE, SQ_SIZE)) 



'''
The main driver for the code. This will handle user input and updating the graphics
'''

def main():

    #Setup before main game logic
    p.init
    screen = p.display.set_mode((WIDTH, HEIGHT))    #creates window set to size of width and height
    clock = p.time.Clock()   #creates timer object for later use
    screen.fill(p.Color("white"))   #sets screen color
    gs = chess_engine.GameState()   #assigns GameState object to gs including a 2d list representing the board
    valid_moves = gs.get_legal_moves() #holds all legal moves to compare with player move
    move_made = False #flag variable for when move is made so you dont have to generate all possible moves every tick
    load_images()  #only call once
    running = True
    
    #Game logic
    selected_sq = () #no square selected initialy. keeps track of selected square (row, column)
    player_clicks = [] #keep track of player clicks. Two tuples containing square coordinates [(2, 2), (4, 2)]
    while running: 
        for e in p.event.get(): 
            if e.type == p.QUIT: #allows closing of game window
                running = False
            #mouse handler
            elif e.type == p.MOUSEBUTTONDOWN:
                location = p.mouse.get_pos() #(x,y) location of mouse on click
                row = location[1]//SQ_SIZE
                column = location[0]//SQ_SIZE

                if selected_sq == (row, column): #user clicked the same square twice
                    selected_sq = () #deselect
                    player_clicks = [] #clear player clicks
                else:
                    selected_sq = (row, column)
                    player_clicks.append(selected_sq) #appends start click and destination click

                if len(player_clicks) == 2: #start and destination has been clicked
                    move = chess_engine.Move(player_clicks[0], player_clicks[1], gs.board)
                    print(move.get_chess_notation())
                    for i, _ in enumerate(valid_moves):# takes players move and finds matching move generated by engine
                        if move == valid_moves[i]:  # and uses engine move that contains more information
                            gs.make_move(valid_moves[i])
                            move_made = True
                            selected_sq = () #resets player clicks after move
                            player_clicks = []
                    if not move_made: #invalid move keeps second click selected
                        player_clicks = [selected_sq]

            #key handler
            elif e.type == p.KEYDOWN:
                if e.key == p.K_LEFT:
                    gs.undo_move()
                    move_made = True

        if move_made:
            valid_moves = gs.get_legal_moves()
            move_made = False

        draw_game_state(screen, gs, valid_moves, selected_sq) #Responsible for all graphics within current game state.
        clock.tick(MAX_FPS) #sets tick rate to max_fps
        p.display.flip() #updates display



'''
Highlight selected square and moves for selected piece
'''

def highlight_squares(screen, gs, valid_moves, selected_sq):
    if selected_sq != ():
        r, c = selected_sq
        if gs.board[r][c][0] == ('w' if gs.white_to_move else 'b'): #makes sure player is selecting their own piece
            #highligh selected square
            s = p.Surface((SQ_SIZE, SQ_SIZE))
            s.set_alpha(100) #transparncy value 0 = opaque | 255 = solid
            s.fill(p.Color('blue'))
            screen.blit(s,(c*SQ_SIZE, r*SQ_SIZE))
            #highlight legal moves
            s.fill(p.Color('black'))
            for move in valid_moves:
                if move.start_row == r and move.start_column == c:
                    screen.blit(s, (move.end_column*SQ_SIZE, move.end_row*SQ_SIZE))






'''
Responsible for all graphics within current game state.
'''

def draw_game_state(screen, gs, valid_moves, selected_sq): #draws game state on screen
    draw_board(screen) #draws squares on board
    highlight_squares(screen, gs, valid_moves, selected_sq)
    draw_pieces(screen, gs.board) #draws pieces on board



'''
Draws squares on board
'''
def draw_board(screen):
    is_white = False

    for row in range(DIMENSION):
        is_white = not is_white #alternates starting color for each row

        for column in range(DIMENSION):
            if is_white:
                color = (239,239,239) #0-255 R,G,B use color picker to find desired color
            else: #blue
                color = (136,119,183)

            tile = p.Rect(SQ_SIZE*column, SQ_SIZE*row, SQ_SIZE, SQ_SIZE) #creates rectangle object needed to draw tlies in screen (x, y, width, height)                                  
            p.draw.rect(screen, color, tile) #draws tile on screen using global screen variable, color variable, and rectangle object
            is_white = not is_white #alternates color every iteration
            



'''
draws pieces on board using GameState.board
'''
def draw_pieces(screen, board):
    for row in range(DIMENSION):
        for column in range(DIMENSION):
            piece = board[row][column]
            if piece != "--": #not empty square
                screen.blit(IMAGES[piece], p.Rect(SQ_SIZE*column, SQ_SIZE*row, SQ_SIZE, SQ_SIZE))

    

if __name__ == '__main__':
    main()